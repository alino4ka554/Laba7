# Ход работы
## 1.	Установка и подготовка среды
Работа выполнялась в среде Ubuntu 22.04. Установлены следующие инструменты:

● clang — компилятор языка C/C++;

● llvm — инструменты анализа и оптимизации кода;

● opt — инструмент для работы с LLVM IR и применения оптимизаций;

● Graphviz — инструмент для визуализации кода.

Команда установки: sudo apt install clang llvm 
![image](https://github.com/user-attachments/assets/19d2dbab-4283-47e9-b891-600fd82ad96a)

 
## 2. Исходный код
Программа на языке C:
```
#include <stdio.h>
int square(int x) {
 return x * x;
}
int main() {
 int a = 5;
 int b = square(a);
 printf("%d\n", b);
 return 0;
}
```
Сохранена в файл main.c. 
![image](https://github.com/user-attachments/assets/91d51069-d0ca-479b-ae73-b829edbf7968)

 
## 3. Получение AST
Команда: clang -Xclang -ast-dump -fsyntax-only main.c 

![image](https://github.com/user-attachments/assets/fbbcde6e-be97-4a5d-b11b-fc7512eaa7d5)

Функция square принята, содержит параметр x и возвращает x * x.

## 4. Генерация LLVM IR
Команда: clang -S -emit-llvm main.c -o main.ll

![image](https://github.com/user-attachments/assets/a4e90a77-4769-4086-a8ba-4a3d3868da29)

 
## 5. Оптимизация IR
Команда: clang -O0 -S -emit-llvm main.c -o main_O0.ll

Стоит отметить, что в файле с IR до оптимизации:

Все переменные (a, b, x.addr) размещены в памяти через alloca;

Множество операций load и store;

square вызывается как отдельная функция.

 ![image](https://github.com/user-attachments/assets/33be62ab-6437-470e-8c7e-6d0e30dbbf27)

Команда: clang -O2 -S -emit-llvm main.c -o main_O2.ll

Команда -O2 – комплексная оптимизация среднего уровня. Она применяет более 30 различных оптимизаций:

● -inline – встраивание небольших функций (встраивает square в main, если она вызывается один раз);

● -constprop – подставит значение square(5) → 25, если функция встроена и всё известно на этапе компиляции;

● -mem2reg – перевод переменных из памяти в регистры (SSA);

● -instcombine – объединение и упрощение инструкций (упростит арифметику, например x * x может быть преобразовано в shl при x = 2^n);

● -simplifycfg – оптимизирует структуру блоков (Упростит граф управления, если после inlining останутся лишние блоки);

● -reassociate, -gvn, -sroa, -dce и другие.

В файле с IR после оптимизации:

Вся функция square исчезла – она была встроена (-inline) и затем вычислена (оптимизация -constprop);

Никаких переменных, alloca, store, load – всё удалено (оптимизации -mem2reg, -dce);

Остался только вызов printf(25).

 ![image](https://github.com/user-attachments/assets/8bd15aa9-32dd-46fc-bfb3-fbff335b5100)

Команда: diff main_O0.ll main_O2.ll
Сравнение двух файлов:

 ![image](https://github.com/user-attachments/assets/31a50998-d12d-4314-8a6a-82e254cfbb39)
![image](https://github.com/user-attachments/assets/7090281b-6953-4983-b53d-ae5983a08f2d)

 
Стоит отметить, что после оптимизации произошли следующие изменения:

● Переменные типа alloca были удалены;

● Код переведён в SSA-форму;

● Оптимизация улучшила читаемость и упростила поток управления.

## 6. Граф потока управления программы

Команда для генерации оптимизированного LLVM IR: clang -O2 -S -emit-llvm main.c -o main.ll

Команда для генерации .dot-файлов CFG для функций: opt -dot-cfg-disable-output main.ll

 ![image](https://github.com/user-attachments/assets/b7fe3999-0a06-4930-be2f-6d25d527b5b6)

Эта команда создаст DOT-файлы: .main.dot – для функции main;  .square.dot – для square, если она не была удалена оптимизацией. 

Команда для установки библиотеки Graphviz: sudo apt install graphviz 

Команды для преобразования файлов с расширением .dot в .png с помощью Graphviz:  

dot -Tpng .main.dot -o cfg_main.png 

dot -Tpng .square.dot -o cfg_square.png 

Команды для просмотра файлов с CGF: 

xdg-open cfg_main.png

 ![image](https://github.com/user-attachments/assets/a81979dd-f3b0-48d1-843a-10aebef721b8)

xdg-open cfg_square.png

 ![image](https://github.com/user-attachments/assets/9a21a53f-04f4-4e28-b104-c48e1bf1a6be)

Стоит отметить, что в LLVM каждый граф потока управления (CFG)  строится на уровне функции, поскольку структура управления всегда  локальна для тела функции. Для получения полного представления о  программе, нужно построить CFG для всех функций и анализировать их  совокупность. Автоматическое объединение всех CFG в один граф не  предусмотрено в LLVM по умолчанию. 
# Выводы 

● С помощью Clang можно получить полную структуру AST и 
IR, а также CGF; 

● LLVM предоставляет гибкие инструменты анализа и 
оптимизации; 

● Промежуточное представление кода удобно для написания 
компиляторных трансформаций.
# Ответы на контрольные вопросы
## 1. Что такое Clang, и какова его роль в процессе компиляции программ?
Clang – это компилятор (фронтенд) для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL, который используется вместе с фреймворком LLVM. Его основная роль – преобразовать исходный код программы в машинный код (или промежуточный код, в зависимости от настроек компиляции). 
## 2. Что представляет собой LLVM и как он используется в современных компиляторах?
LLVM – это проект программной инфраструктуры, используемый для создания компиляторов и других утилит, связанных с компиляцией. Он предоставляет набор инструментов для компиляции, оптимизации и интерпретации кода. LLVM позволяет разрабатывать компиляторы для различных языков программирования, а также предоставляет платформенную независимость, позволяя создавать код, работающий на разных архитектурах. 
## 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?
AST — это структурированное представление исходного кода, отражающее синтаксис и структуру программы. Его строит Clang после разбора исходного кода на C/C++.
LLVM IR — это низкоуровневое, платформонезависимое представление программы, ближе к машинному коду. Его генерирует Clang после анализа AST.
## 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
Промежуточное представление нужно в процессе компиляции для того, чтобы упростить и стандартизировать анализ, оптимизацию и генерацию машинного кода. Оно позволяет отделить этап разбора исходного языка от этапа генерации исполняемого файла, облегчая поддержку разных языков программирования и архитектур. Благодаря IR компилятор может применять универсальные оптимизации и работать с программой на более низком уровне, но ещё до создания платформозависимого кода.
## 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?
Инструкция alloca выделяет память на стеке внутри функции. Она используется для создания локальных переменных, аналогично тому, как в C создаются переменные внутри функции. Позволяет временно хранить данные, пока выполняется функция.
## 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
Оптимизация улучшает производительность и уменьшает размер кода. Цель — сделать программу быстрее, использовать меньше памяти, упростить структуру, устранить ненужные вычисления и повысить эффективность выполнения.
## 7. Что такое SSA-форма и почему она важна при оптимизации программ?
SSA — форма представления программы, в которой каждая переменная присваивается только один раз. Это упрощает анализ зависимостей между переменными и позволяет компилятору безопасно и эффективно выполнять оптимизации, такие как устранение мёртвого кода или подстановка значений.
## 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
CFG — это граф, где узлы представляют блоки кода, а рёбра — возможные переходы исполнения. Он помогает понять, как программа выполняется, где могут возникать ветвления, циклы и условия, и служит основой для анализа и оптимизации кода.
## 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
Арифметические операции в LLVM IR записываются как команды низкого уровня, например add, mul, sub. Они работают с переменными и константами напрямую и похожи на ассемблерные инструкции, но платформонезависимы.
## 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?
Потому что каждая функция имеет независимую структуру управления и переменные. Это позволяет анализировать и оптимизировать её изолированно, встраивать (inline) в другие функции или удалять, если она не используется.
## 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?
Компилятор может встроить её (inline) в вызывающую функцию. После этого она может быть удалена, если нигде больше не используется. Это уменьшает количество вызовов и ускоряет выполнение.
## 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?
IR и CFG упрощают структуру программы, устраняют синтаксическую сложность и делают поведение кода более предсказуемым. Это позволяет применять универсальные и мощные оптимизации, которые невозможно или сложно выполнить на уровне исходного текста.
